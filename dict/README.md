# 字典

>Go 语言的字典类型其实是一个哈希表（hash table）的特定实现。在这个实现中，键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。

>Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。

>如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）

## 求哈希和判等操作的速度越快，对应的类型就越适合作为键类型

>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于***字符串类型***，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。

>类型的宽度是指它的单个值需要占用的字节数。比如，bool、int8和uint8类型的一个值需要占用的字节数都是1，因此这些类型的宽度就都是1。

>在那些基本类型中应该优先选择哪一个？答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。

那什么是不通常的情况？笼统地说，Go 语言有时会对字典的增、删、改、查操作做一些优化。

比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为4或8的整数类型的情况下。

## 在值为nil的字典上执行读操作会成功吗，那写操作呢？
    当我们仅仅声明字典不初始化时，它的值会是nil。
    除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。

```
func NilDictDoSomething() {
	var m map[int]int
	for key, value := range m {
		fmt.Printf("map's key = %d,value = %d", key, value)
	}
}
```